#include "data-chunk-storage.h"

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <string>
#include <sys/types.h>
#include <stdint.h>
#include <atomic>
#include <assert.h>

#include "../common-headers/common-enums.h"
#include "data-chunk-types.h"

#include "original-memory-fnc-pointers.h"


// Output paths string are not std::strings because of malloc
char *outputFilePath;
char *outputSummaryFilePath;


// File descriptor which represent binary logging file.
static int logFileFd;


// Flag which lock store chung function to make it thread safe
// TODO: Second flag will be probably used for acceleration of writing 
// into file in parallel apps.
std::atomic_flag storeChunkLock = ATOMIC_FLAG_INIT;


// Initialize data chunk storage.
// Find if the output path is presented inside at environment variables
void DataChunStorage::initDataChunkStorage()
{
    //Search through environment variables to find out output path. 
    //If output path is found, merge it with output file names.
    char *path = getenv(ENV_OUTPUT_PATH);
    if(path != NULL)
    {
        // Compute size of full path and add 10 to make sure it will have
        // enough space.
        int pathSize = strlen(path) + strlen(LOG_FILE) + 10;
        outputFilePath = (char*)libcMalloc(pathSize);

        assert(outputFilePath != NULL);

        strcat(outputFilePath, path);
        strcat(outputFilePath, "/");
        strcat(outputFilePath, LOG_FILE);

        // Set full output summary file name.
        pathSize = strlen(path) + strlen(LOG_FILE_SUMARY) + 10;
        outputSummaryFilePath = (char*)libcMalloc(pathSize);

        assert(outputSummaryFilePath != NULL);

        strcat(outputSummaryFilePath, path);
        strcat(outputSummaryFilePath, "/");
        strcat(outputSummaryFilePath, LOG_FILE_SUMARY);
    }
    else    // No environment variable found.
    {
        // Set default output file name.
        int pathSize = strlen(LOG_FILE) + 1;
        outputFilePath = (char*)libcMalloc(pathSize);
        assert(outputFilePath != NULL);
        strcat(outputFilePath, LOG_FILE);

        // Set default output summary file name.
        pathSize = strlen(LOG_FILE_SUMARY) + 1;
        outputSummaryFilePath = (char*)libcMalloc(pathSize);
        strcat(outputSummaryFilePath, LOG_FILE_SUMARY);
    }
    printf("output: %s\n", outputFilePath);
    printf("output-sumary: %s\n", outputSummaryFilePath);

    // Check if summary log file can be created.
    int testFile = open(outputSummaryFilePath, O_WRONLY | O_CREAT | O_TRUNC,
                        S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
    if(testFile == -1)
    {
        printf("Can't open/create %s file!!!", outputSummaryFilePath);
        exit(1);
    }
    close(testFile);


    // Truncate binary trace file and write header. Header are 4 bytes and 
    // it store size of pointer (size can be dependent on HW architecture).
    logFileFd = open(outputFilePath, O_WRONLY | O_CREAT | O_TRUNC ,
                     S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
    if(logFileFd == -1)
    {
        printf("Can't open/create %s file!!!", outputFilePath);
        exit(1);
    }
    u_int8_t sizeOfPointer = sizeof(void*);
    u_int8_t backtraceLength = BACK_TRACE_LENGTH;
    write(logFileFd, &sizeOfPointer, sizeof(u_int8_t));
    write(logFileFd, &backtraceLength, sizeof(u_int8_t));
    fsync(logFileFd);
}


void DataChunStorage::deinitDataChunkStorage()
{
    close(logFileFd);
}


// Store data chunk generated by memory hooks
void DataChunStorage::storeDataChunk(void *dataChunk)
{
    while (storeChunkLock.test_and_set()) {} // lock function

    int writeSize;

    switch((int)((DataChunkBase*)dataChunk)->typeNumberId)
    {
    case CHUNK_TYPE_ID_MALLOC:
        writeSize = sizeof(DataChunkMalloc);
        break;
    case CHUNK_TYPE_ID_FREE:
        writeSize = sizeof(DataChunkFree);
        break;
    case CHUNK_TYPE_ID_CALLOC:
        writeSize = 0;  // Set to zero for now.
        break;
    case CHUNK_TYPE_ID_REALLOC:
        writeSize = 0;  // Set to zero for now.
        break;
    case CHUNK_TYPE_ID_MEMALIGN:
        writeSize = 0;  // Set to zero for now.
        break;
    default:
        writeSize = 0;
        break;
    }

    write(logFileFd, dataChunk, writeSize);

    storeChunkLock.clear(); // unlock function
}


void DataChunStorage::storeSummary(int mallocCount, int freeCount,
                                   int callocCount, int reallocCount,
                                   int memalignCount)
{
    // Open text logging file and truncate it (new summary will be written).
    int summaryLogFileFd = open(outputSummaryFilePath, O_WRONLY | O_CREAT |
                               O_TRUNC,
                               S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);

    // Generate new summary message.
    // This method was chosen because of no memory allocation is presented.
    char string[200];
    sprintf(string, "malloc: %d\nfree: %d\ncalloc: %d\nrealloc: %d\n"
            "memalign: %d\n", mallocCount, freeCount, callocCount, reallocCount,
            memalignCount);
    // Write message into file
    write(summaryLogFileFd, &string, strlen(string));
    // Close logging file
    close(summaryLogFileFd);
}
